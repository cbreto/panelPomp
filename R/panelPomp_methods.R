## methods for panelPomp objects (other than workhorses: pfilter, mif2, etc.)

#' @include panelPomp.R
NULL

#' @name panelPomp_methods
#' @docType methods
#' @title Manipulating \code{panelPomp} objects
#' @description Tools for manipulating \code{panelPomp} objects.
#' @param object,x An object of class \code{panelPomp} or inheriting class 
#' \code{panelPomp}.
#' @param start,end position in original \code{times(pomp)} at which to start 
#' @param U how many units to keep (starting from the first).
#' and end the window.
#' @param unitname name of panel unit to be manipulated.
#' @param value value to be assigned.
#' @param ... ....
#' @section Methods:
#' \describe{
#'   \item{coef}{Extracts coefficients of \code{panelPomp} objects.}
#'   \item{coef<-}{Assign coefficients to \code{panelPomp} objects.}
#'   \item{length}{Count the number of units in \code{panelPomp} objects.}
#'   \item{names}{Get the unit names of \code{panelPomp} objects.}
#'   \item{pparams}{Extracts coefficients from \code{panelPomp} objects.}
#'   \item{unitobjects}{Extracts \code{pomp} objects from \code{panelPomp} 
#'   objects.}
#'   \item{window}{Subset \code{panelPomp} objects by changing start time, 
#'   end time, and number of units.}
#'   }
#' @author Carles Breto and Aaron A. King.
#' @family panelPomp methods
NULL

#' @rdname panelPomp_methods
#' @export
setMethod(
  "coef",
  signature=signature(object="panelPomp"),
  definition = function (object) {
    pmat <- object@specific
    c(
      object@shared,
      setNames(
        as.numeric(pmat),
        outer(rownames(pmat),colnames(pmat),sprintf,fmt="%s[%s]")
      )
    )
  }
)

#' @rdname panelPomp_methods
#' @export
setMethod(
  "coef<-",
  signature=signature(object="panelPomp"),
  definition=function (object, ..., value) {
    ## check names(value)
    ep <- paste0("in ",sQuote("coef<-"),": ")
    if (!identical(character(0),setdiff(names(value),names(coef(object))))) 
      stop(paste0(ep,"part of ",sQuote("value")," is not part of ",
                  sQuote("coef(object)"),"."),call.=FALSE)
    if (!identical(character(0),setdiff(names(coef(object)),names(value)))) 
      stop(paste0(ep,"part of ",sQuote("coef(object)")," is not specified in ",
                  sQuote("value"),"."),call.=FALSE)
    nn <- grep("^.+\\[.+?\\]$",names(value),perl=TRUE,value=TRUE)
    pp <- sub(pattern="^(.+?)\\[.+?\\]$",replacement="\\1",x=nn,perl=TRUE)
    uU <- names(object@unit.objects)
    pU <- sort(unique(pp))
    object@specific <- array(dim=c(length(pU),length(uU)),
                                     dimnames=list(param=pU,unit=uU))
    pvec <- setNames(numeric(length(object@specific)),
                     outer(pU,uU,sprintf,fmt="%s[%s]"))
    unitpar <- intersect(names(value),names(pvec))
    sharedpar <- setdiff(names(value),unitpar)
    pvec[unitpar] <- value[unitpar]
    object@specific[,] <- pvec
    object@shared <- value[sort(sharedpar)]
    ## is the new object valid?
    #tryCatch(validObject(object),
    #         error=function (e) {stop(ep,conditionMessage(e),call.=FALSE)})
    object
  }
)

#' @rdname panelPomp_methods
#' @export
setMethod(
  "length",
  signature=signature(x="panelPomp"),
  definition = function (x) length(unitobjects(x))
)

#' @rdname panelPomp_methods
#' @export
setMethod(
  "names",
  signature=signature(x="panelPomp"),
  definition = function (x) names(x@unit.objects)
)

#' @rdname panelPomp_methods
#' @export
setMethod(
  "pparams",
  signature=signature(object="panelPomp"),
  definition = function (object) 
    list(shared=object@shared,specific=object@specific)
)

#' @rdname panelPomp_methods
#' @export
pParams <- function (value) {
  nn <- grep("^.+\\[.+?\\]$",names(value),perl=TRUE,value=TRUE)
  shs <- names(value)[!names(value)%in%nn]
  pp <- sub(pattern="^(.+?)\\[.+?\\]$",replacement="\\1",x=nn,perl=TRUE)
  sps <- sort(unique(pp))
  uu <- sub(pattern="^(.+?)\\[(.+?)\\]$",replacement="\\2",x=nn,perl=TRUE)
  us <- sort(unique(uu))
  pParams <- list(shared=numeric(0),specific=array(numeric(0),dim=c(0,0)))
  if (length(shs)>0) pParams$shared <- value[shs]
  if (length(sps)>0) {
    pParams$specific <- array(dim=c(length(sps),length(us)),
                              dimnames=list(param=sps,unit=us))
    for (sp in sps) {
      pParams$specific[sp,us] <- value[paste0(sp,"[",us,"]")]
    }
  }
  pParams
}

#' @rdname panelPomp_methods
#' @export
setMethod(
  f = "unitobjects",
  signature = signature(object = "panelPomp"),
  definition = function(object,
                        unitname) {
    if (missing(unitname)) {
      return(object@unit.objects)
    } else {
      return(object@unit.objects[unitname][[1]])
    }
  }
)

#' @rdname panelPomp_methods
#' @export
setMethod(
  "window",
  signature=signature(x="panelPomp"),
  definition=function (x, U, start, end) {
    if (missing(U)) U <- length(x)
    po <- as(x,"list")[[1]]
    if (missing(start)) start <- 1
    if (missing(end)) end <- length(time(po))
    panelPomp(
      lapply(as(x,"list")[1:U],FUN=window,start=time(po)[start],
             end=time(po)[end]),
      shared=x@shared,
      specific=x@specific[,1:U,drop=FALSE]
    )
  }
)

## "@rdname panelPomp_methods" doesn't seem to work with setAs()
## coerce method
#' @title Coercing \code{panelPomp} objects as a \code{list}
#' @description Extracts the \code{unit.objects} slot of \code{panelPomp} 
#' objects.
#' @name as
#' @family panelPomp methods
setAs(from="panelPomp",to="list",def = function (from) from@unit.objects)
