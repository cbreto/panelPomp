[
  {
    "objectID": "todo.html",
    "href": "todo.html",
    "title": "Website TODO list",
    "section": "",
    "text": "Create a bibliography page with all citations to the package (add to website side-bar)\nCheck that the package TAR Ball and ZIP file also get created in the GitHub Action so that these files will be up-to-date if there are any changes to the packages. I’m worried that the current links will be to old versions of the package.\nCreate Vignettes and non-Vignette examples for the package, link to them in the sidebar.\nUpdate the index page\nImprove the website documentation in the testpkg website, so that this is all reproducible and possibly can be extended to spatPomp and/or pomp.\nAdd link to this website on personal website.\n(Not related to this project, but personal TODO item and this is a good place for me to put it): Create this same website-workflow for arima2.\nIt’s a little annoying all GitHub actions run every time you push, even if the changes are only to the website. Exclude the website directory from the GHA workflow for building, testing, code-coverage, etc."
  },
  {
    "objectID": "bibliography.html",
    "href": "bibliography.html",
    "title": "Bibliography",
    "section": "",
    "text": "Yang, B. 2023. “Analysis of Panel Data via Mechanistic Models in PanelPOMP Framework”. Honors Thesis. (Link)\n\n\nMorales Miranda, A. 2023. “Quantifying the effect of climate on respiratory viruses: From seasonality to interannual variability”. PhD Thesis in Mathematics: University of Illinois at Urbana-Champaign. (Link)\n\n\nDomeyer, J. E., Lee, J. D., Toyoda, H., Mehler, B., Reimer, B. 2022. “Driver-pedestrian perceptual models demonstrate coupling: implications for vehicle automation”. IEEE Transactions on Human-Machine Systems. (Link)\n\n\nSubramanian, R. 2021. “Inferring the Extent and Impact of Heterogeneity during Emerging Virus Outbreaks”. PhD Thesis: The University of Chicago.\n\n\nLee, E. C., et al. 2020. “Achieving Coordinated National Immunity and Cholera Elimination in Haiti Through Vaccination: A Modelling Study”. The Lancet Global Health. (Link)\n\n\nBretó, C., Ionides, E. L., King, A. A. 2019. “Panel data analysis via mechanistic models”. Journal of the American Statistical Association. (Link)\n\n\nRanjeva, S., et al. 2019. “Age-specific differences in the dynamics of protective immunity to influenza”. Nature Communications. (Link)\n\n\nWale, N., Jones, M. J., Sim, D. G., Read, A. F., King, A. A. 2019. “The contribution of host cell-directed vs. parasite-directed immunity to the disease and dynamics of malaria infections”. Proceedings of the National Academy of Sciences. (Link)\n\n\nYang, X. 2018. “Fitting mechanistic models to Daphnia panel data within a panelPOMP framework”. Honors Thesis. (Link)\n\n\nRanjeva, S. L., et al. 2017. “Recurring infection with ecologically distinct HPV types can explain high prevalence and diversity”. Proceedings of the National Academy of Sciences. (Link)\n\n\nRomero-Severson, E. O., Volz, E., Koopman, J. S., Leitner, T., Ionides, E. L. 2015. “Dynamic Variation in Sexual Contact Rates in a Cohort of HIV-Negative Gay Men”. American Journal of Epidemiology. (Link)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "panelPomp",
    "section": "",
    "text": "Authors\nCarles Bretó (carles.breto@uv.es), Edward L. Ionides, Aaron A. King and Jesse Wheeler (jeswheel@umich.edu)\n\n\nInference for PanelPOMPs (Panel Partially Observed Markov Processes)\nThe panelPomp package provides facilities for inference on panel data using panel partially-observed Markov process (PanelPOMP) models. To do so, it relies on and extends a number of facilities that the pomp package provides for inference on time series data using partially-observed Markov process (POMP) models.\nThe panelPomp package extends to panel data some of the capabilities of the pomp package to fit nonlinear, non-Gaussian dynamic models. This is done accommodating both fixed and random effects. Currently, the focus is on likelihood-based approaches. In addition to these likelihood-based tools, panelPomp also provides a framework under which alternative statistical methods for PanelPOMP models can be developed (very much like pomp provides a platform upon which statistical inference methods for POMP models can be implemented).\n\n\nData analysis using panelPomp\nThe first step in using panelPomp is to encode one’s model(s) and data in objects of class panelPomp. One does this via a call to the panelPomp::panelPomp constructor function.\nThe current panelPomp version provides algorithms for\n\nparticle filtering of panel data (AKA sequential Monte Carlo or sequential importance sampling), as proposed in Bret, Ionides and King (2020). This reference provides the fundamental theoretical support for the averaging of Monte Carlo replicates of panel unit likelihoods as implemented in panelPomp; see the pfilter function documentation.\nthe panel iterated filtering method of Bret, Ionides and King (2020). This reference provides the fundamental theoretical support for the extensions of the iterated filtering ideas of Ionides et al. (2006, 2011, 2015) to panel data as implemented in panelPomp; see the mif2 function documentation.\n\nThe package also provides various tools for handling and extracting information on models and data.\n\n\nExtending the platform for developing inference tools\npanelPomp extends to panel data the general interface to the components of POMP models provided by pomp. In doing so, it contributes to the goal of the pomp project of facilitating the development of new algorithms in an environment where they can be tested and compared on a growing body of models and datasets.\n\n\nComments, bug reports, and requests\nContributions are welcome, as are suggestions for improvement, feature requests, and bug reports. Please submit these via the panelPomp issues page. We particularly welcome minimal working examples displaying uninformative, misleading or inacurate error messages. We also welcome suggestions for clarifying obscure passages in the documentation. Help requests are welcome, but please consider before sending requests whether they are regarding the use of panelPomp or that of pomp. For help with pomp, please visit pomp’s FAQ."
  },
  {
    "objectID": "news.html",
    "href": "news.html",
    "title": "panelPomp",
    "section": "",
    "text": "News for package ‘panelPomp’\n\n\nChanges in panelPomp version 1.2.0\n\n\n\n\nChange the generic unitlogLik to unitLogLik to match camel-case style of package. The original function is deprecated in this version and will be removed in future updates.\n\n\n\n\nChanged panelPomp S4 object slot name from unit.objects to unit_objects in order to be consistent with pomp pacakge. Corresponding getter and setter methods for this slot have also been changed from unitobjects() to unit_objects().\n\n\n\n\nAdded generics shared(), shared()&lt;-, specific(), and specific()&lt;-. These generics provide convinient access to parameters of a panelPomp object, but the setter methods also allow for changing a parameter type between shared and unit-specific.\n\n\n\n\nAdded function runif_panel_design(), which is useful for generating design matrices for PanelPOMP models.\n\n\n\n\nMinor typo fixes to package and function documentation.\n\n\n\n\nChanges in panelPomp version 1.1.0.2\n\n\n\n\nAdded a type check for the params arguement of the pfilter function in order to throw more user friendly error.\n\n\n\n\nA more user friendly error is thrown when the user specifies a parameter as both shared and unit specific in the mif2 function.\n\n\n\n\nAdded a match.arg call in mif2.internal; this will allow the default option for the cooling.type argument in mif2 to no longer throw an error, and mimics the behaviour of the mif2 function in the pomp package.\n\n\n\n\nThe pParams function no longer changes the order of the unit specific parameter names; this was causing an error because the barycentric parameter transformation requires that the parameters are adjacent to one another in the parameter vector.\n\n\n\n\nImproved documentation for panel_logmeanexp.\n\n\n\n\nMore robust input checking for the pfilter function with user friendly error messages.\n\n\n\n\nChanges in panelPomp version 1.1.0\n\n\n\n\nImproved documentation and tests.\n\n\n\n\nChanges in panelPomp version 1.0.0\n\n\n\n\nSubmitted to CRAN.\n\n\n\n\nChanges in panelPomp version 0.18.0\n\n\n\n\nFixed bug in fromVectorPparams() to make it a true inverse of toVectorPparams().\n\n\n\n\nHomogenized documentation; added examples.\n\n\n\n\nChanges in panelPomp version 0.15.0\n\n\n\n\nNew coercion to pompList and update to list.\n\n\n\n\npanelGompertzLikelihood replaces kalman_gompertz.R.\n\n\n\n\nexpunged panelPompExample.\n\n\n\n\nNames added to plot; pfilter matches units by name.\n\n\n\n\nChanges in panelPomp version 0.14.0\n\n\n\n\nNew simulate function.\n\n\n\n\nChanges in panelPomp version 0.13.0\n\n\n\n\nNew panelRandomWalk example.\n\n\n\n\npanelPompExample is now deprecated and will be removed in the near future.\n\n\n\n\nChanges in panelPomp version 0.12.0\n\n\n\n\nNew plot method for panelPomp objects.\n\n\n\n\nChanges in panelPomp version 0.11.0\n\n\n\n\nAdditional functions implementing Kalman filtering to panels and to the Gompertz model.\n\n\n\n\nChanges in panelPomp version 0.10.2.0\n\n\n\n\nMinor improvements to the interface.\n\n\n\n\nAdditional examples: contacts() and panelGompertz().\n\n\n\n\nThe minimum version of pomp supported is now 2.7.\n\n\n\n\nChanges in panelPomp version 0.9.1\n\n\n\n\nThe minimum version of pomp supported is now 2.1. While this is likely to imply substantial changes in pomp objects (on which panelPomp objects rely) there are only three fundamental changes that break panelPomp’s backwards compatibility:\n\n\n\n\nThe first argument pfilter(object, …) changes to data.\n\n\n\n\nThe first argument mif2(object, …) changes to data.\n\n\n\n\nThe ‘conv.rec’ method has been deprecated, replaced by the new ‘traces’ method.\n\n\n\n\nChanges in panelPomp version 0.8.3\n\n\n\n\nImprovements to the interface.\n\n\n\n\nChanges in panelPomp version 0.7\n\n\n\n\nA new conv.rec method.\n\n\n\n\nChanges in panelPomp version 0.6\n\n\n\n\nMany improvements to the interface.\n\n\n\n\nChanges in panelPomp version 0.5.6\n\n\n\n\npanelPompExamples() now allows creating panelPomp objects that come with the package.\n\n\n\n\nNew documentation and tests.\n\n\n\n\nChanges in panelPomp version 0.5.5\n\n\n\n\nNew documentation and tests.\n\n\n\n\nChanges in panelPomp version 0.5.4\n\n\n\n\nNew documentation and tests.\n\n\n\n\nChanges in panelPomp version 0.5.3\n\n\n\n\nNew documentation and additional tests.\n\n\n\n\nChanges in panelPomp version 0.5\n\n\n\n\nNew documentation and additional tests and coverage.\n\n\n\n\nChanges in panelPomp version 0.4\n\n\n\n\nNew tests added.\n\n\n\n\nNew methods.\n\n\n\n\nA bug in pfilter and mif2 has been fixed (pomp’s default filtering tolerance tol=1e-17 was used instead of values specified by the user). Thanks to Aaron King for finding it.\n\n\n\n\nChanges in panelPomp version 0.2\n\n\n\n\nNew tests added.\n\n\n\n\nEliminate need to protect rw.sd from being evaluated.\n\n\n\n\nChanges in panelPomp version 0.1\n\n\n\n\nUnused variable purged.\n\n\n\n\npPfilter.internal streamlined.\n\n\n\n\nTest for reproducibility of pfilter calculations added."
  },
  {
    "objectID": "vignettes/getting-started.html",
    "href": "vignettes/getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "library(panelPomp)\n#&gt; Loading required package: pomp"
  },
  {
    "objectID": "vignettes/getting-started.html#introduction",
    "href": "vignettes/getting-started.html#introduction",
    "title": "Getting Started",
    "section": "Introduction",
    "text": "Introduction\nPanel data arise when time series are measured on a collection of units. When the time series for each unit is modeled as a partially observed Markov process (POMP) the collection of these models is a PanelPOMP. The panelPomp package provides facilities for inference on panel data using PanelPOMP models. Monte Carlo methods used for POMP models require adaptation for PanelPOMP models due to the higher dimensionality of panel data. This package builds on the functionality and tools of the popular pomp R package, providing a computationally efficient framework that can be used to simulate from, fit, and diagnose PanelPOMP models. As such, a basic working knowledge of the pomp package is recommended. Here we cover some of the necessary basics. See Getting Started With pomp for an introductory Vignette to the pomp package."
  },
  {
    "objectID": "vignettes/getting-started.html#mathematical-notation",
    "href": "vignettes/getting-started.html#mathematical-notation",
    "title": "Getting Started",
    "section": "Mathematical Notation",
    "text": "Mathematical Notation\nBefore discussing features of the panelPomp package, we describe a mathematical notation that is helpful in communicating details about panelPomp code and models. The general scope of the panelPomp package requires notation concerning random variables and their densities in arbitrary spaces. The notation below allows us to talk about these things using the language of mathematics, enabling precise description of models and algorithms.\nUnits of the panel can be identified with numeric labels \\(\\{1,2,\\dots,U\\}\\), which we also write as \\(1:U\\). Let \\(N_u\\) be the number of measurements collected on unit \\(u\\), allowing for the possibility that a different number of observations are collected for each unit. The data from the entire panel are written as \\(y^*_{1:U,1:N_u} = \\{y^*_{1,1}, y^*_{2,1},\\dots, y^*_{U, 1}, y^*_{1,2}\\ldots, y^*_{u,N_u}\\}\\) where the \\(n^{th}\\) observation from unit \\(u\\) (denoted as \\(y^*_{u,n}\\)) is collected at time \\(t_{u,n}\\) with \\(t_{u,1}&lt;t_{u,2}&lt;\\dots&lt;t_{u,N_u}\\). Observation times \\(\\{t_{u, n}\\}\\) are often equally spaced, but this general framework and notation permit unequally spaced observations times both across and within units. The data from unit \\(u\\) are modeled as a realization of an observable stochastic process \\(Y_{u,1:N_u}\\) which is dependent on a latent Markov process \\(\\{X_{u}(t),t_{u,0}\\le t\\le t_{u,N_u}\\}\\) defined subsequent to an initial time \\(t_{u,0}\\le t_{u,1}\\). Requiring that \\(\\{X_u(t)\\}\\) and \\(\\{Y_{u,i},i\\neq n\\}\\) are independent of \\(Y_{u,n}\\) given \\(X_u(t_{u,n})\\), for each \\(n\\in 1: N_{u}\\), completes the partially observed Markov process (POMP) model structure for unit \\(u\\). For a PanelPOMP we require additionally that all units are modeled as independent.\nWhile the latent process may exist between measurement times, its value at measurement times is of particular interest. We write \\(X_{u,n}=X_u(t_{u,n})\\) to denote the latent process at the observation times. We suppose that \\(X_{u,n}\\) and \\(Y_{u,n}\\) take values in arbitrary spaces \\(\\mathbb{X}_{u}\\) and \\(\\mathbb{Y}_{u}\\) respectively. Using the independence of units, conditional independence of the observable random variables, and the Markov property of the latent states, the joint distribution of the entire collection of latent variables \\(\\mathbf{X} = \\{X_{u,0:N_u}\\}_{u = 1}^U\\) and observable variables \\(\\mathbf{Y} = \\{Y_{u,1:N_u}\\}_{u = 1}^U\\) can be written as: \\[\nf_{\\mathbf{X}\\mathbf{Y}}(\\mathbf{x}, \\mathbf{y}) = \\prod_{u = 1}^U f_{X_{u, 0}}(x_{u,0}; \\theta)\\prod_{n = 1}^{N_u} f_{Y_{u, n}|X_{u, n}}(y_{u, n}|x_{u, n}; \\theta)f_{X_{u, n}|X_{u, n-1}}(x_{u, n}|x_{u, n-1}; \\theta),\n\\] where \\(\\theta\\in\\mathbb{R}^{D}\\) is a possibly unknown parameter vector. This representation is useful as it demonstrates how any PanelPOMP model can be fully described using three primary components: the transition densities \\(f_{X_{u,n}|X_{u,n-1}}(x_{u,n}| x_{u,n-1};\\theta)\\), measurement densities \\(f_{Y_{u,n}|X_{u,n}}(y_{u,n}| x_{u,n}:\\theta)\\), and initialization densities \\(f_{X_{u, 0}}(x_{u,0}; \\theta)\\). Each class of densities are permitted to depend arbitrarily on \\(u\\) and \\(n\\), allowing non-stationary models and the inclusion of covariate time series. In addition to continuous-time dynamics, the framework includes discrete-time dynamic models by specifying \\(X_{u,0:N_u}\\) directly without ever defining \\(\\{X_u(t),t_{u,0}\\le t\\le t_{u,N_u}\\}\\).\n\nLikelihood Function\nThe marginal density of \\(Y_{u,1:N_u}\\) at \\(y_{u,1:N_u}\\) is \\(f_{Y_{u,1:N_u}}(y_{u,1:N_u};\\theta)\\) and the likelihood function for unit \\(u\\) is \\(L_{u}(\\theta) = f_{Y_{u,1:N_u}}(y^*_{u,1:N_u};\\theta)\\). The likelihood for the entire panel is \\(L(\\theta) = \\prod_{u=1}^{U} L_{u}(\\theta)\\), and any solution \\(\\hat\\theta=\\arg\\max L(\\theta)\\) is a maximum likelihood estimate (MLE). The log likelihood is \\(\\ell(\\theta)=\\log L(\\theta)\\). We also permit the possibility that some parameters may affect only a subset of units, so that the parameter vector can be written as \\(\\theta=(\\phi,\\psi_1,\\dots,\\psi_U)\\), where the important densities described above can be written as \\[\nf_{X_{u,n}\\vert X_{u,n-1}}(x_{u,n}| x_{u,n-1} ; \\theta)=f_{X_{u,n}|X_{u,n-1}}(x_{u,n}| x_{u,n-1} ; \\phi,\\psi_u)\n\\tag{1}\\]\n\\[\nf_{Y_{u,n}|X_{u,n}}(y_{u,n}| x_{u,n} ; \\theta) = f_{Y_{u,n}|X_{u,n}}(y_{u,n}| x_{u,n} ; \\phi,\\psi_u)\n\\tag{2}\\]\n\\[\nf_{X_{u,0}}(x_{u,0} ; \\theta) = f_{X_{u,0}}(x_{u,0} ; \\phi,\\psi_u)\n\\tag{3}\\]\nThen, \\(\\psi_{u}\\) is a vector of unit-specific parameters for unit \\(u\\), and \\(\\phi\\) is a shared parameter vector. We suppose \\(\\phi\\in\\mathbb{R}^{A}\\) and \\(\\psi\\in\\mathbb{R}^{B}\\), so the dimension of the parameter vector \\(\\theta\\) is \\(D=A+B U\\). In practice, the densities in Equation 1–Equation 3 serve two primary roles in PanelPOMP models: evaluation and simulation. The way these fundamental goals are represented in the panelPomp package is described in Table 1.\n\n\n\nTable 1: Basic mathematical functions of all PanelPOMP models and their representation in the panelPomp\n\n\n\n\n\n\n\n\n\nMethod\nMathematical terminology\n\n\n\n\nrprocess\nSimulate from Equation 1: \\(f_{X_{u,n}\\vert X_{u,n-1}}(x_{u,n}| x_{u,n-1} ; \\theta)\\)\n\n\ndprocess\nEvaluate Equation 1: \\(f_{X_{u,n}| X_{u,n-1}}(x_{u,n}| x_{u,n-1} ; \\theta)\\)\n\n\nrmeasure\nSimulate from Equation 2: \\(f_{Y_{u,n}|X_{u,n}}(y_{u,n}| x_{u,n} ; \\phi,\\psi_u)\\)\n\n\ndmeasure\nEvaluate Equation 2: \\(f_{Y_{u,n}|X_{u,n}}(y_{u,n}| x_{u,n} ; \\phi,\\psi_u)\\)\n\n\nrinit\nSimulate from Equation 3: \\(f_{X_{u,0}}(x_{u,0} ; \\phi,\\psi_u)\\)\n\n\ndinit\nEvaluate Equation 3: \\(f_{X_{u,0}}(x_{u,0} ; \\phi,\\psi_u)\\)\n\n\n\n\n\n\nEach independent unit in a panel is POMP model, represented using the pomp package. Each pomp object contains the same components described in Table 1, with the exception that parameters cannot be shared across individual units in the panel. As such, the functions listed in Table 1 are available in the panelPomp package through the pomp package. Additional functions of interest that are not listed in Table 1 include: rprior() and dprior(), enabling the use of Bayesian analysis if desired; emeasure() and vmeasure(), which describe the conditional expectation and covariance of the measurement model for algorithms that rely on these values (such as the Kalman filter)."
  },
  {
    "objectID": "vignettes/getting-started.html#panelpomp-objects",
    "href": "vignettes/getting-started.html#panelpomp-objects",
    "title": "Getting Started",
    "section": "panelPomp objects",
    "text": "panelPomp objects\nThe panelPomp package is written in a functional object oriented programming framework. Key to the most important features of the package is the panelPomp class, which is implemented using the S4 system. This S4 class contains three slots:\n\nunit_objects: A list of pomp objects.\nshared: a named numeric vector containing the names and values of parameters that are shared for each unit of the panel.\nspecific: a numeric matrix with row and column names; row names correspond to the parameter names, and column names to the unit names of the panel.\n\nNotably, the functions listed in Table 1 are not part of a panelPomp object directly, rather they are part of the individual unit objects saved in the slot unit_objects. These objects can be extracted using the extracter function: unit_objects(&lt;object&gt;).\n\nConstructing panelPomp objects\nThe fundamental mathematical functions that define a PanelPOMP model are made available via the pomp objects in the unit_objects slot. As such, constructing a panelPomp object is simple if you are already familiar with constructing pomp objects, or if you already have access to pomp objects. Here we describe how to create a panelPomp object if the unit-specific pomp objects are already created. In the next sub-section, we give a brief demonstration of how to construct a panelPomp object from scratch, including each individual pomp object. Here, we construct a panelPomp object representing a panel of stochastic Gompertz population models with log-normal measurement error. The latent state process is defined as: \\[\nX_{n + 1} = K^{1-S}X_n^S\\epsilon_n,\n\\] where \\(S = \\exp^{-r}\\) and the \\(\\epsilon_n\\) are i.i.d. lognormal random variables with variance \\(\\sigma^2\\). The measurement model for the observed variables \\(Y_n\\) are distributed as: \\[\nY_n \\sim \\text{Lognormal}\\big(\\log X_n, \\tau \\big).\n\\] The parameters of this model are:\n\nPer-capita growth rate \\(r\\).\nThe carrying capacity \\(K\\).\nThe process noise standard deviation \\(\\sigma\\).\nThe measurement error standard deviation \\(\\tau\\).\nThe initial condition \\(X_0\\).\n\nThis particular model class has a constructor function gompertz() from the pomp package. Here, we create 5 unique instances of this model, and use these instances to create a single panelPomp object:\n\nmod1 &lt;- pomp::gompertz()  # Using default values \nmod2 &lt;- pomp::gompertz(K = 2, r = 0.01)  # Overwriting some of the defaults \nmod3 &lt;- pomp::gompertz(K = 1.5, sigma = 0.15, X_0 = 5)\nmod4 &lt;- pomp::gompertz(K = 1.5, r = 0.05, X_0 = 5)\nmod5 &lt;- pomp::gompertz(K = 5, sigma = 0.08)\n\npanelMod1 &lt;- panelPomp(\n  object = list(mod1, mod2, mod3, mod4, mod5)\n)\n\nOne important thing to note above the above construction is that each individual model already has parameter values present. When this is the case, the panelPomp() constructor sets all parameters to be unit specific:\n\nprint(specific(panelMod1))\n#&gt;          unit\n#&gt; parameter unit1 unit2 unit3 unit4 unit5\n#&gt;     K       1.0  2.00  1.50  1.50  5.00\n#&gt;     r       0.1  0.01  0.10  0.05  0.10\n#&gt;     sigma   0.1  0.10  0.15  0.10  0.08\n#&gt;     tau     0.1  0.10  0.10  0.10  0.10\n#&gt;     X_0     1.0  1.00  5.00  5.00  1.00\nprint(shared(panelMod1))\n#&gt; numeric(0)\n\nIn the panelMod1 object, all five parameters are listed as unit specific. Notably, because \\(\\tau\\) was not modified in any of the unit specific objects, it has the same value across all five units. In such cases, it might make sense to list parameters that have the same value across all units as shared parameters, which can be done in the model constructor:\n\npanelMod2 &lt;- panelPomp(\n  object = list(mod1, mod2, mod3, mod4, mod5),\n  shared = c(\"tau\" = 0.1)\n)\n\nspecific(panelMod2)\n#&gt;          unit\n#&gt; parameter unit1 unit2 unit3 unit4 unit5\n#&gt;     K       1.0  2.00  1.50  1.50  5.00\n#&gt;     r       0.1  0.01  0.10  0.05  0.10\n#&gt;     sigma   0.1  0.10  0.15  0.10  0.08\n#&gt;     X_0     1.0  1.00  5.00  5.00  1.00\nshared(panelMod2)\n#&gt; tau \n#&gt; 0.1\n\nIn this case we did not need to explicitly specify unit-specific parameters; if parameter values are present in the unit pomp objects that comprise the panel, parameters are assumed to be unit-specific unless otherwise specified. However, it is possible to explicitly provide a matrix of unit specific parameters in the constructor, if desired. This is especially important if the individual pomp objects that make up the panel have missing parameter values.\nUnit-specific parameters can be expressed in two ways: as a matrix with rows corresponding to parameter values and columns the corresponding unit (as seen above), or as a named numeric vector that follows the convention &lt;param&gt;[&lt;unit name&gt;]:\n\nspecific(panelMod2, format = 'vector')\n#&gt;     K[unit1]     r[unit1] sigma[unit1]   X_0[unit1]     K[unit2]     r[unit2] \n#&gt;         1.00         0.10         0.10         1.00         2.00         0.01 \n#&gt; sigma[unit2]   X_0[unit2]     K[unit3]     r[unit3] sigma[unit3]   X_0[unit3] \n#&gt;         0.10         1.00         1.50         0.10         0.15         5.00 \n#&gt;     K[unit4]     r[unit4] sigma[unit4]   X_0[unit4]     K[unit5]     r[unit5] \n#&gt;         1.50         0.05         0.10         5.00         5.00         0.10 \n#&gt; sigma[unit5]   X_0[unit5] \n#&gt;         0.08         1.00\n\nIt is often convenient to modify which parameters are shared and which are unit-specific on existing panelPomp objects rather than creating new objects from scratch. This can be done with the shared&lt;- and specific&lt;- setter functions:\n\nshared(panelMod2) &lt;- c('r' = 0.05, 'sigma' = 0.1)\nspecific(panelMod2) &lt;- c('tau[unit1]' = 0.11, 'tau[unit4]' = 0.09)\n\nprint(shared(panelMod2))\n#&gt;     r sigma \n#&gt;  0.05  0.10\nprint(specific(panelMod2))\n#&gt;      unit\n#&gt; param unit1 unit2 unit3 unit4 unit5\n#&gt;   K    1.00   2.0   1.5  1.50   5.0\n#&gt;   tau  0.11   0.1   0.1  0.09   0.1\n#&gt;   X_0  1.00   1.0   5.0  5.00   1.0\n\nNotice above that if a shared parameter (tau) is changed to a unit-specific parameter and not all values of the unit-specific parameter are explicitly provided, the parameters that are not specified default to the original shared value. The unit-specific setter function also works in matrix format:\n\nspecific(panelMod2) &lt;- matrix(\n  data = rbind(c(1.24, 1.78), \n               c(   2,    3)),\n  nrow = 2, \n  dimnames = list(\n    param = c(\"K\", \"X_0\"), \n    unit = c('unit2', 'unit4')\n  )\n)\n\nspecific(panelMod2)\n#&gt;      unit\n#&gt; param unit1 unit2 unit3 unit4 unit5\n#&gt;   K    1.00  1.24   1.5  1.78   5.0\n#&gt;   X_0  1.00  2.00   5.0  3.00   1.0\n#&gt;   tau  0.11  0.10   0.1  0.09   0.1\n\nNeither the shared&lt;- nor the specific&lt;- setter functions allow a user to add new parameters (or unit names) that are not already part of the model:\n\nshared(panelMod2) &lt;- c(\"foo\" = 1)\n#&gt; Error: in 'shared&lt;-': 'value' contains parameters not found in 'object'.\n\n\nspecific(panelMod2) &lt;- c(\"tau[unit6]\" = 1)\n#&gt; Error: in 'specific&lt;-': 'value' contains unit names not in 'object'."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "panelPomp",
    "section": "",
    "text": "Authors and Contributors\nCarles Bretó (carles.breto@uv.es) [aut, cre], Edward L. Ionides [aut], Aaron A. King [aut], and Jesse Wheeler (jeswheel@umich.edu) [aut].\n\n\nVersion\n\n\n\n\n\nGitHub\n1.2.0\n\n\nCRAN\n1.1\n\n\n\n\n\n\n\nPackage Description\nData analysis based on panel partially-observed Markov process (PanelPOMP) models. To implement such models, simulate them and fit them to panel data, ‘panelPomp’ extends some of the facilities provided for time series data by the ‘pomp’ package. Implemented methods include filtering (panel particle filtering) and maximum likelihood estimation (Panel Iterated Filtering) as proposed in Bretó, Ionides and King (2020) “Panel Data Analysis via Mechanistic Models” doi:10.1080/01621459.2019.1604367.\n\n\nDepends\n\n\n\n\n\ntype\npackage\nversion\n\n\n\n\nDepends\nR\n&gt;= 4.1.0\n\n\nDepends\npomp\n&gt;= 4.5.2\n\n\nImports\nlifecycle\n*\n\n\nImports\nmethods\n*\n\n\nSuggests\nknitr\n*\n\n\nSuggests\nrmarkdown\n*\n\n\nSuggests\nbookdown\n*\n\n\n\n\n\n\n\nLicense\nGPL-3"
  }
]